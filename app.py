import streamlit as st
from streamlit_cookies_manager import EncryptedCookieManager
import uuid
import random
import time
import io
from PIL import Image, ImageDraw, ImageFont
import pandas as pd
from datetime import datetime
import os
from supabase import create_client, Client

# --- Inicializando o Cookie Manager ---
# Certifique-se de instalar a biblioteca: pip install streamlit-cookies-manager
# Substitua "SUA_CHAVE_SECRETA_AQUI" por uma chave secreta de sua preferência.
cookies = EncryptedCookieManager(key="cvPE_PGmCLhwLDcd5vODQvZ6z8KxI2Fw2m2gF_rvQkI
")
if not cookies.ready():
    st.stop()

if "user_id" not in cookies:
    user_id = str(uuid.uuid4())
    cookies["user_id"] = user_id
    cookies.save()  # Salva o cookie no navegador
else:
    user_id = cookies["user_id"]

# Armazena o user_id no session_state para uso interno na aplicação
st.session_state["user_id"] = user_id

# --- Configuração Inicial do Streamlit ---
st.set_page_config(
    page_title="Sistema de Atribuição de Números",
    layout="centered",
    initial_sidebar_state="expanded"
)

# --- CSS Personalizado ---
st.markdown("""
<style>
    .main-header {text-align: center; margin-bottom: 30px;}
    .number-display {font-size: 72px; text-align: center; margin: 30px 0;}
    .success-msg {background-color: #d4edda; color: #155724; padding: 10px; border-radius: 5px;}
    .error-msg {background-color: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px;}
</style>
""", unsafe_allow_html=True)

# --- Funções da Aplicação ---

def get_supabase_client() -> Client:
    """Estabelece conexão com o Supabase utilizando variáveis de ambiente."""
    supabase_url = os.getenv("SUPABASE_URL")
    supabase_key = os.getenv("SUPABASE_KEY")
    if not supabase_url or not supabase_key:
        st.error("Credenciais do Supabase não configuradas no ambiente.")
        return None
    try:
        client = create_client(supabase_url, supabase_key)
        client.table("_dummy").select("*").limit(1).execute()
        return client
    except Exception as e:
        st.error(f"Erro ao conectar ao Supabase: {str(e)}")
        return None

def check_table_exists(supabase, table_name):
    """Verifica se uma tabela específica existe no Supabase."""
    try:
        supabase.table(table_name).select("*").limit(1).execute()
        return True
    except Exception:
        return False

def create_meeting_table(supabase, table_name, meeting_name, max_number=999):
    """Cria uma nova tabela para uma reunião no Supabase e registra os metadados."""
    try:
        # Passo 1: Registrar os metadados da reunião
        response_metadata = supabase.table("meetings_metadata").insert({
            "table_name": table_name,
            "meeting_name": meeting_name,
            "created_at": datetime.now().isoformat(),
            "max_number": max_number
        }).execute()

        # Passo 2: Criar a tabela dinamicamente via RPC
        create_table_query = f"""
        CREATE TABLE public.{table_name} (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            number INTEGER NOT NULL,
            assigned BOOLEAN DEFAULT FALSE,
            assigned_at TIMESTAMPTZ,
            user_id TEXT
        );
        """
        supabase.rpc("execute_sql", {"query": create_table_query}).execute()

        # Aguarda a propagação
        time.sleep(1)
        if not check_table_exists(supabase, table_name):
            raise Exception(f"Tabela {table_name} não foi criada com sucesso no Supabase.")

        # Passo 3: Inserir os números na nova tabela em lotes
        batch_size = 100
        for i in range(0, max_number, batch_size):
            end = min(i + batch_size, max_number)
            data = [{"number": j, "assigned": False, "assigned_at": None, "user_id": None} 
                    for j in range(i+1, end+1)]
            supabase.table(table_name).insert(data).execute()
        
        return True
    except Exception as e:
        st.error(f"Erro ao criar tabela da reunião: {str(e)}")
        try:
            supabase.table("meetings_metadata").delete().eq("table_name", table_name).execute()
            supabase.rpc("execute_sql", {"query": f"DROP TABLE IF EXISTS public.{table_name}"}).execute()
        except Exception as rollback_e:
            st.error(f"Erro no rollback: {str(rollback_e)}")
        return False

def get_available_meetings(supabase):
    """Recupera a lista de reuniões disponíveis a partir da tabela de metadados."""
    try:
        response = supabase.table("meetings_metadata").select("*").execute()
        return response.data if response.data else []
    except Exception as e:
        st.error(f"Erro ao recuperar reuniões: {str(e)}")
        return []

def generate_number_image(number):
    """Gera uma imagem contendo o número atribuído."""
    width, height = 600, 300
    img = Image.new("RGB", (width, height), color=(255, 255, 255))
    draw = ImageDraw.Draw(img)
    
    # Fundo com gradiente
    for y in range(height):
        r = int(220 - y/3)
        g = int(240 - y/3)
        b = 255
        for x in range(width):
            draw.point((x, y), fill=(r, g, b))
    
    # Carregar fonte
    try:
        font = ImageFont.truetype("Arial.ttf", 200)
    except IOError:
        font = ImageFont.load_default()
    
    # Centralizar o número na imagem
    number_text = str(number)
    bbox = draw.textbbox((0, 0), number_text, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    text_position = ((width - text_width) // 2, (height - text_height) // 2)
    draw.text(text_position, number_text, font=font, fill=(0, 0, 100))
    
    img_buffer = io.BytesIO()
    img.save(img_buffer, format="PNG")
    img_buffer.seek(0)
    return img_buffer

def generate_participant_link(table_name):
    """Gera um link para os participantes acessarem a reunião."""
    base_url = "https://app-number.streamlit.app"
    return f"{base_url}/?table={table_name}&mode=participant"

# --- Verificação do Modo de Operação ---

query_params = st.query_params
mode = query_params.get("mode", "master")
table_name_from_url = query_params.get("table", None)

if mode == "participant" and table_name_from_url:
    # --- Modo Participante ---
    st.markdown("<h1 class='main-header'>Pegue seu Número</h1>", unsafe_allow_html=True)
    supabase = get_supabase_client()
    if not supabase:
        st.stop()
    
    if not check_table_exists(supabase, table_name_from_url):
        st.error("Reunião não encontrada ou inválida.")
        st.stop()
    
    try:
        meeting_info = supabase.table("meetings_metadata").select("*").eq("table_name", table_name_from_url).execute()
        meeting_name = meeting_info.data[0]["meeting_name"] if meeting_info.data else "Reunião"
        st.subheader(f"Reunião: {meeting_name}")
    except Exception:
        st.subheader("Pegue um número para a reunião")

    # Utiliza o user_id persistido via cookies
    user_id = st.session_state["user_id"]
    try:
        # Verifica se o usuário já possui um número atribuído
        existing = supabase.table(table_name_from_url).select("number").eq("user_id", user_id).execute()
        if existing.data:
            assigned_number = existing.data[0]["number"]
            st.session_state["assigned_number"] = assigned_number
            st.markdown(f"""
            <div class='success-msg'>
                <p>Seu número atribuído é:</p>
                <div class='number-display'>{st.session_state['assigned_number']}</div>
            </div>
            """, unsafe_allow_html=True)
        else:
            # Se nenhum número estiver atribuído, gera um novo número
            with st.spinner("Atribuindo um número..."):
                response = supabase.table(table_name_from_url).select("*").eq("assigned", False).execute()
                if response.data:
                    available_numbers = [row["number"] for row in response.data]
                    assigned_number = random.choice(available_numbers)
                    supabase.table(table_name_from_url).update({
                        "assigned": True,
                        "assigned_at": datetime.now().isoformat(),
                        "user_id": user_id
                    }).eq("number", assigned_number).execute()
                    st.session_state["assigned_number"] = assigned_number
                    st.markdown(f"""
                    <div class='success-msg'>
                        <p>Seu número atribuído é:</p>
                        <div class='number-display'>{st.session_state['assigned_number']}</div>
                    </div>
                    """, unsafe_allow_html=True)
                else:
                    st.error("Todos os números já foram atribuídos!")
                    st.stop()
    except Exception as e:
        st.error(f"Erro ao atribuir número: {str(e)}")
        st.stop()
    
    if st.button("Salvar como Imagem"):
        with st.spinner("Gerando imagem..."):
            img_buffer = generate_number_image(st.session_state["assigned_number"])
            st.image(img_buffer)
            st.download_button(
                "Download da Imagem",
                img_buffer,
                file_name=f"meu_numero_{st.session_state['assigned_number']}.png",
                mime="image/png"
            )

else:
    # --- Modo Master ---
    valid_pages = ["Gerenciar Reuniões", "Compartilhar Link", "Ver Estatísticas"]
    if "page" not in st.session_state or st.session_state["page"] not in valid_pages:
        st.session_state["page"] = "Gerenciar Reuniões"

    st.sidebar.title("Menu (Master)")
    page = st.sidebar.radio("Escolha uma opção", valid_pages, index=valid_pages.index(st.session_state["page"]))

    # --- Página 1: Gerenciar Reuniões ---
    if page == "Gerenciar Reuniões":
        st.session_state["page"] = "Gerenciar Reuniões"
        st.markdown("<h1 class='main-header'>Gerenciar Reuniões</h1>", unsafe_allow_html=True)
        supabase = get_supabase_client()
        if not supabase:
            st.stop()
        
        with st.form("create_meeting_form"):
            st.subheader("Criar Nova Reunião")
            meeting_name = st.text_input("Nome da Reunião")
            max_number = st.number_input("Número Máximo", min_value=10, max_value=10000, value=999)
            submit_button = st.form_submit_button("Criar Reunião")
            
            if submit_button:
                if meeting_name:
                    table_name = f"meeting_{int(time.time())}_{meeting_name.lower().replace(' ', '_')}"
                    if check_table_exists(supabase, table_name):
                        st.error("Uma reunião com esse nome já existe. Tente outro nome.")
                    else:
                        with st.spinner("Criando reunião..."):
                            success = create_meeting_table(supabase, table_name, meeting_name, max_number)
                            if success:
                                participant_link = generate_participant_link(table_name)
                                st.success(f"Reunião '{meeting_name}' criada com sucesso!")
                                st.markdown(f"**Link para Participantes:** [{participant_link}]({participant_link})")
                                st.session_state["selected_table"] = table_name
                                st.session_state["page"] = "Compartilhar Link"
                                st.experimental_rerun()
                            else:
                                st.error("Falha ao criar a reunião.")
                else:
                    st.warning("Por favor, insira um nome para a reunião.")
        
        st.subheader("Reuniões Existentes")
        meetings = get_available_meetings(supabase)
        if meetings:
            meeting_data = []
            for meeting in meetings:
                if "table_name" in meeting and "meeting_name" in meeting:
                    table_name = meeting["table_name"]
                    if check_table_exists(supabase, table_name):
                        try:
                            count_response = supabase.table(table_name).select("*", count="exact").eq("assigned", True).execute()
                            assigned_count = count_response.count if hasattr(count_response, 'count') else 0
                            participant_link = generate_participant_link(table_name)
                            meeting_data.append({
                                "Nome": meeting.get("meeting_name", "Sem nome"),
                                "Tabela": table_name,
                                "Link": participant_link,
                                "Criada Em": meeting.get("created_at", "")[:16].replace("T", " "),
                                "Números Atribuídos": assigned_count,
                                "Total de Números": meeting.get("max_number", 0)
                            })
                        except Exception as e:
                            st.warning(f"Erro ao processar reunião {table_name}: {str(e)}")
                    else:
                        st.warning(f"Tabela {table_name} não existe no banco de dados.")
            if meeting_data:
                df = pd.DataFrame(meeting_data)
                st.dataframe(df)
            else:
                st.info("Nenhuma reunião válida encontrada.")
        else:
            st.info("Nenhuma reunião disponível ou erro ao acessar o Supabase.")

    # --- Página 2: Compartilhar Link (Master) ---
    elif page == "Compartilhar Link":
        st.session_state["page"] = "Compartilhar Link"
        st.markdown("<h1 class='main-header'>Compartilhar Link</h1>", unsafe_allow_html=True)
        
        supabase = get_supabase_client()
        if not supabase:
            st.stop()
        
        meetings = get_available_meetings(supabase)
        if not meetings:
            st.info("Nenhuma reunião disponível. Crie uma reunião primeiro.")
            st.stop()
        
        options = {f"{m['meeting_name']} ({m['table_name']})": m["table_name"] 
                   for m in meetings if "table_name" in m and "meeting_name" in m}
        selected = st.selectbox("Selecione uma reunião para compartilhar:", list(options.keys()))
        
        if selected:
            selected_table = options[selected]
            participant_link = generate_participant_link(selected_table)
            st.markdown(f"**Link para Participantes:** [{participant_link}]({participant_link})")
            if st.button("Copiar Link"):
                st.write("Link copiado para a área de transferência!")
                st.code(participant_link)

    # --- Página 3: Ver Estatísticas ---
    elif page == "Ver Estatísticas":
        st.session_state["page"] = "Ver Estatísticas"
        st.markdown("<h1 class='main-header'>Estatísticas da Reunião</h1>", unsafe_allow_html=True)
        supabase = get_supabase_client()
        if not supabase:
            st.stop()
        
        meetings = get_available_meetings(supabase)
        if not meetings:
            st.info("Nenhuma reunião disponível para análise.")
            st.stop()
        
        options = {f"{m['meeting_name']} ({m['table_name']})": m["table_name"] 
                   for m in meetings if "table_name" in m and "meeting_name" in m}
        selected = st.selectbox("Selecione uma reunião:", list(options.keys()))
        
        if selected:
            selected_table = options[selected]
            try:
                total_response = supabase.table(selected_table).select("*", count="exact").execute()
                total_numbers = total_response.count if hasattr(total_response, 'count') else 0
                assigned_response = supabase.table(selected_table).select("*", count="exact").eq("assigned", True).execute()
                assigned_numbers = assigned_response.count if hasattr(assigned_response, 'count') else 0
                percentage = (assigned_numbers / total_numbers) * 100 if total_numbers > 0 else 0
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Total de Números", total_numbers)
                with col2:
                    st.metric("Números Atribuídos", assigned_numbers)
                with col3:
                    st.metric("Percentual Atribuído", f"{percentage:.1f}%")
                
                try:
                    time_data_response = supabase.table(selected_table).select("*").eq("assigned", True).order("assigned_at").execute()
                    if time_data_response.data:
                        time_data = []
                        for item in time_data_response.data:
                            if item.get("assigned_at"):
                                time_data.append({
                                    "time": item.get("assigned_at")[:16].replace("T", " "),
                                    "count": 1
                                })
                        if time_data:
                            df = pd.DataFrame(time_data)
                            df["time"] = pd.to_datetime(df["time"])
                            df["hour"] = df["time"].dt.floor("H")
                            hourly_counts = df.groupby("hour").count().reset_index()
                            hourly_counts["hour_str"] = hourly_counts["hour"].dt.strftime("%m/%d %H:00")
                            st.subheader("Atribuições de Número por Hora")
                            st.bar_chart(data=hourly_counts, x="hour_str", y="count")
                except Exception:
                    st.info("Dados temporais não disponíveis para esta reunião.")
                
                if st.button("Exportar Dados"):
                    try:
                        all_data_response = supabase.table(selected_table).select("*").execute()
                        if all_data_response.data:
                            df = pd.DataFrame(all_data_response.data)
                            csv = df.to_csv(index=False)
                            st.download_button(
                                "Download CSV",
                                csv,
                                file_name=f"{selected_table}_export.csv",
                                mime="text/csv"
                            )
                    except Exception as e:
                        st.error(f"Erro ao exportar dados: {str(e)}")
            except Exception as e:
                st.error(f"Erro ao recuperar estatísticas: {str(e)}")

if __name__ == "__main__":
    pass  # O Streamlit executa o script diretamente
